# ÊäÄË°ìÁöÑËß£Ê±∫Á≠ñ„Å®ÂÆüË£Ö„Ç¨„Ç§„Éâ

ÊúÄÁµÇÊõ¥Êñ∞Êó•: 2025-07-18

## üîß ÂÖ∑‰ΩìÁöÑ„Å™ÊäÄË°ìÁöÑËß£Ê±∫Á≠ñ

### 1. API„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆ‰øÆÊ≠£

#### ÂïèÈ°å: createdAt„Éï„Ç£„Éº„É´„Éâ„ÅÆ„Éë„Éº„Çπ„Ç®„É©„Éº

**ÁèæÂú®„ÅÆ„Ç≥„Éº„ÉâÔºàÂïèÈ°å„ÅÇ„ÇäÔºâ**:
```python
created_at=datetime.fromisoformat(data['createdAt'].replace('Z', '+00:00'))
```

**‰øÆÊ≠£Ê°à**:
```python
def _safe_parse_datetime(self, date_string: Optional[str]) -> datetime:
    """ÂÆâÂÖ®„Å´Êó•ÊôÇÊñáÂ≠óÂàó„Çí„Éë„Éº„Çπ"""
    if not date_string:
        return datetime.now(timezone.utc)
    
    # Ë§áÊï∞„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÇíË©¶„Åô
    formats = [
        "%Y-%m-%dT%H:%M:%S.%fZ",  # 2023-12-01T10:30:45.123Z
        "%Y-%m-%dT%H:%M:%SZ",      # 2023-12-01T10:30:45Z
        "%Y-%m-%dT%H:%M:%S%z",     # 2023-12-01T10:30:45+00:00
    ]
    
    for fmt in formats:
        try:
            if date_string.endswith('Z'):
                # Z„Çí„Çø„Ç§„É†„Çæ„Éº„É≥„Å´Â§âÊèõ
                date_string = date_string[:-1] + '+00:00'
            return datetime.strptime(date_string, fmt)
        except ValueError:
            continue
    
    # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: isoformat
    try:
        return datetime.fromisoformat(date_string.replace('Z', '+00:00'))
    except:
        logger.warning(f"Failed to parse date: {date_string}")
        return datetime.now(timezone.utc)
```

#### ÂïèÈ°å: „É¢„Éá„É´„Çø„Ç§„Éó„ÅÆÂ§ßÊñáÂ≠óÂ∞èÊñáÂ≠ó

**‰øÆÊ≠£Ê°à**:
```python
# interfaces.py
class ModelType(str, Enum):
    """Model types with case-insensitive comparison"""
    CHECKPOINT = "Checkpoint"
    LORA = "LoRA"
    TEXTUAL_INVERSION = "Textual Inversion"
    HYPERNETWORK = "Hypernetwork"
    AESTHETIC_GRADIENT = "Aesthetic Gradient"
    CONTROLNET = "Controlnet"
    POSES = "Poses"
    
    @classmethod
    def _missing_(cls, value):
        """Â§ßÊñáÂ≠óÂ∞èÊñáÂ≠ó„ÇíÁÑ°Ë¶ñ„Åó„Å¶Ê§úÁ¥¢"""
        if isinstance(value, str):
            # ÂÆåÂÖ®‰∏ÄËá¥„ÇíË©¶„Åô
            for member in cls:
                if member.value.lower() == value.lower():
                    return member
            # ÈÉ®ÂàÜ‰∏ÄËá¥„ÇíË©¶„Åô
            for member in cls:
                if value.lower() in member.value.lower():
                    return member
        return None
```

### 2. ÈùûÂêåÊúüÂá¶ÁêÜ„ÅÆÊúÄÈÅ©Âåñ

#### „Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ„ÅÆÊîπÂñÑ

**ÁèæÂú®„ÅÆÂïèÈ°å**: „Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÈñâ„Åò„Çâ„Çå„ÅüÂæå„Å´„Ç¢„ÇØ„Çª„Çπ„Åï„Çå„Çã

**‰øÆÊ≠£Ê°à**:
```python
class CivitAIAPIClient:
    def __init__(self, config: ConfigManager):
        self.config = config
        self.session: Optional[aiohttp.ClientSession] = None
        self._session_lock = asyncio.Lock()
        self._is_closed = False
    
    async def _ensure_session(self):
        """„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂ≠òÂú®„Åô„Çã„Åì„Å®„Çí‰øùË®º"""
        async with self._session_lock:
            if self._is_closed:
                raise RuntimeError("API client has been closed")
            
            if self.session is None or self.session.closed:
                self.session = await self._create_session()
    
    async def _create_session(self) -> aiohttp.ClientSession:
        """Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Çí‰ΩúÊàê"""
        connector = aiohttp.TCPConnector(
            limit=10,  # ÂêåÊôÇÊé•Á∂öÊï∞„ÇíÂà∂Èôê
            limit_per_host=5,  # „Éõ„Çπ„Éà„Åî„Å®„ÅÆÊé•Á∂öÊï∞„ÇíÂà∂Èôê
            ttl_dns_cache=300,
            enable_cleanup_closed=True
        )
        
        timeout = aiohttp.ClientTimeout(
            total=60,  # ÂÖ®‰Ωì„ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÇíÂ¢ó„ÇÑ„Åô
            connect=10,
            sock_read=30
        )
        
        return aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers=self._get_default_headers()
        )
    
    async def _make_request(self, method: str, endpoint: str, **kwargs):
        """„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂÆüË°åÔºàËá™Âãï„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜÔºâ"""
        await self._ensure_session()
        
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            async with self.session.request(method, url, **kwargs) as response:
                response.raise_for_status()
                return await response.json()
        except asyncio.TimeoutError:
            raise APIError("Request timed out")
        except aiohttp.ClientError as e:
            raise APIError(f"Network error: {e}")
```

### 3. „ÉÜ„Çπ„Éà„ÅÆ‰øÆÊ≠£

#### ÈùûÂêåÊúü„É¢„ÉÉ„ÇØ„ÅÆÊ≠£„Åó„ÅÑË®≠ÂÆö

**ÂïèÈ°å„ÅÆ„ÅÇ„Çã„ÉÜ„Çπ„Éà**:
```python
# ÁèæÂú®„ÅÆ„Ç≥„Éº„ÉâÔºàÂãï‰Ωú„Åó„Å™„ÅÑÔºâ
mock_session.get.return_value.__aenter__.return_value = mock_response
```

**‰øÆÊ≠£Ê°àÔºàaioresponses„Çí‰ΩøÁî®Ôºâ**:
```python
# requirements-dev.txt„Å´ËøΩÂä†
# aioresponses>=0.7.4

import aioresponses

@pytest.mark.asyncio
async def test_download_file_with_aioresponses():
    """aioresponses„Çí‰Ωø„Å£„ÅüÊ≠£„Åó„ÅÑ„ÉÜ„Çπ„Éà"""
    with aioresponses.aioresponses() as mock:
        # „É¢„ÉÉ„ÇØ„É¨„Çπ„Éù„É≥„Çπ„ÇíË®≠ÂÆö
        test_url = "https://example.com/model.safetensors"
        test_content = b"fake model content"
        
        mock.get(test_url, body=test_content, status=200,
                headers={'Content-Length': str(len(test_content))})
        
        # „ÉÜ„Çπ„ÉàÂÆüË°å
        config = ConfigManager()
        async with DownloadManager(config) as dm:
            with tempfile.NamedTemporaryFile(delete=False) as tmp:
                await dm.download_file(test_url, Path(tmp.name))
                
                # Ê§úË®º
                downloaded = Path(tmp.name).read_bytes()
                assert downloaded == test_content
```

### 4. „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊîπÂñÑ

#### „Éê„ÉÉ„ÉÅÂá¶ÁêÜ„Å®„Ç≠„É£„ÉÉ„Ç∑„É≥„Ç∞

```python
class OptimizedSearchEngine(ModelSearchEngine):
    def __init__(self, api_client: IAPIClient):
        super().__init__(api_client)
        self._request_cache = TTLCache(maxsize=100, ttl=300)  # 5ÂàÜ„Ç≠„É£„ÉÉ„Ç∑„É•
        self._semaphore = asyncio.Semaphore(3)  # ÂêåÊôÇ„É™„ÇØ„Ç®„Çπ„ÉàÊï∞„ÇíÂà∂Èôê
    
    async def search_batch(self, params_list: List[SearchParams]) -> List[List[ModelInfo]]:
        """Ë§áÊï∞„ÅÆÊ§úÁ¥¢„ÇíÂäπÁéáÁöÑ„Å´ÂÆüË°å"""
        tasks = []
        for params in params_list:
            # „Ç≠„É£„ÉÉ„Ç∑„É•„Ç≠„Éº„ÇíÁîüÊàê
            cache_key = self._get_cache_key(params)
            
            if cache_key in self._request_cache:
                # „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâËøî„Åô
                tasks.append(asyncio.create_task(
                    self._return_cached(self._request_cache[cache_key])
                ))
            else:
                # Êñ∞Ë¶è„É™„ÇØ„Ç®„Çπ„Éà
                tasks.append(asyncio.create_task(
                    self._search_with_semaphore(params)
                ))
        
        return await asyncio.gather(*tasks)
    
    async def _search_with_semaphore(self, params: SearchParams) -> List[ModelInfo]:
        """„Çª„Éû„Éï„Ç©„ÅßÂà∂Èôê„Åï„Çå„ÅüÊ§úÁ¥¢"""
        async with self._semaphore:
            results = await self.search(params)
            # „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
            cache_key = self._get_cache_key(params)
            self._request_cache[cache_key] = results
            return results
```

### 5. „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÅÆÁµ±‰∏Ä

```python
# exceptions.py
class CivitAIError(Exception):
    """Âü∫Â∫ï‰æãÂ§ñ„ÇØ„É©„Çπ"""
    pass

class APIError(CivitAIError):
    """APIÈñ¢ÈÄ£„ÅÆ„Ç®„É©„Éº"""
    def __init__(self, message: str, status_code: Optional[int] = None):
        super().__init__(message)
        self.status_code = status_code

class NetworkError(APIError):
    """„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÈñ¢ÈÄ£„ÅÆ„Ç®„É©„Éº"""
    pass

class RateLimitError(APIError):
    """„É¨„Éº„ÉàÂà∂Èôê„Ç®„É©„Éº"""
    def __init__(self, retry_after: Optional[int] = None):
        super().__init__("Rate limit exceeded")
        self.retry_after = retry_after

class ValidationError(CivitAIError):
    """„Éê„É™„Éá„Éº„Ç∑„Éß„É≥„Ç®„É©„Éº"""
    pass

# „Ç®„É©„Éº„Éè„É≥„Éâ„É©„Éº
class ErrorHandler:
    @staticmethod
    def handle_api_error(error: Exception) -> str:
        """API„Ç®„É©„Éº„Çí„É¶„Éº„Ç∂„Éº„Éï„É¨„É≥„Éâ„É™„Éº„Å™„É°„ÉÉ„Çª„Éº„Ç∏„Å´Â§âÊèõ"""
        if isinstance(error, RateLimitError):
            if error.retry_after:
                return f"Rate limit exceeded. Please wait {error.retry_after} seconds."
            return "Rate limit exceeded. Please try again later."
        
        if isinstance(error, NetworkError):
            return "Network connection error. Please check your internet connection."
        
        if isinstance(error, ValidationError):
            return f"Invalid input: {str(error)}"
        
        if isinstance(error, APIError):
            if error.status_code == 404:
                return "Model not found."
            elif error.status_code == 403:
                return "Access denied. Please check your API key."
            
        return f"An error occurred: {str(error)}"
```

### 6. CLIÊîπÂñÑ

```python
# cli.py improvements
import click
from functools import wraps

def handle_errors(f):
    """„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Éá„Ç≥„É¨„Éº„Çø"""
    @wraps(f)
    def wrapper(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except CivitAIError as e:
            click.echo(f"Error: {ErrorHandler.handle_api_error(e)}", err=True)
            ctx = click.get_current_context()
            ctx.exit(1)
        except Exception as e:
            if click.get_current_context().obj.get('debug'):
                raise
            click.echo(f"Unexpected error: {str(e)}", err=True)
            ctx = click.get_current_context()
            ctx.exit(1)
    return wrapper

@cli.command()
@click.argument('model_id', type=int)
@click.pass_context
@handle_errors
def show(ctx, model_id: int):
    """Show model details with better error handling."""
    config = ctx.obj['config']
    
    async def _show():
        async with CivitAIAPIClient(config) as client:
            # „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÇíË°®Á§∫
            with click.progressbar(length=1, label='Fetching model details') as bar:
                model = await client.get_model_details(model_id)
                bar.update(1)
            
            # Ë©≥Á¥∞„ÇíË°®Á§∫
            preview = PreviewManager(client, config)
            preview.display_model_info(model)
    
    asyncio.run(_show())
```

## üìà „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Éô„É≥„ÉÅ„Éû„Éº„ÇØ

ÂÆüË£ÖÂæå„ÅÆÊúüÂæÖ„Åï„Çå„ÇãÊîπÂñÑ:

| „É°„Éà„É™„ÉÉ„ÇØ | ÁèæÂú® | ÊîπÂñÑÂæå | ÊîπÂñÑÁéá |
|-----------|------|--------|--------|
| APIÂëº„Å≥Âá∫„ÅóÊôÇÈñì | 2-3Áßí | 0.5-1Áßí | 60-80% |
| Ê§úÁ¥¢„É¨„Çπ„Éù„É≥„Çπ | „Çø„Ç§„É†„Ç¢„Ç¶„Éà | <5Áßí | - |
| „É°„É¢„É™‰ΩøÁî®Èáè | 200MB | 150MB | 25% |
| ÂêåÊôÇ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ | 1 | 5 | 500% |

## üîÑ „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Ë®àÁîª

1. **Phase 1**: „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Å®„Éê„É™„Éá„Éº„Ç∑„Éß„É≥Ôºà‰∫íÊèõÊÄßÁ∂≠ÊåÅÔºâ
2. **Phase 2**: „Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ„ÅÆÊîπÂñÑÔºàÂÜÖÈÉ®Â§âÊõ¥„ÅÆ„ÅøÔºâ
3. **Phase 3**: „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©ÂåñÔºà„Ç™„Éó„Éà„Ç§„É≥Ê©üËÉΩÔºâ
4. **Phase 4**: Á†¥Â£äÁöÑÂ§âÊõ¥Ôºà„É°„Ç∏„É£„Éº„Éê„Éº„Ç∏„Éß„É≥„Ç¢„ÉÉ„ÉóÔºâ

„Åì„Çå„Çâ„ÅÆÊäÄË°ìÁöÑËß£Ê±∫Á≠ñ„ÇíÊÆµÈöéÁöÑ„Å´ÂÆüË£Ö„Åô„Çã„Åì„Å®„Åß„ÄÅ„Ç∑„Çπ„ÉÜ„É†„ÅÆÂÆâÂÆöÊÄß„Å®‰Ωø„ÅÑ„ÇÑ„Åô„Åï„ÇíÂ§ßÂπÖ„Å´ÊîπÂñÑ„Åß„Åç„Åæ„Åô„ÄÇ